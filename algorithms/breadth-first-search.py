# Граф моделирует набор связей.
# Графы состоят из узлов и ребер. Узел может быть напрямую
# соединен с несколькими другими узлами. Эти узлы называются соседями.
# - Поиск в ширину позволяет определить, существует ли путь из А в В.
# - Если путь существует, то поиск в ширину находит кратчайший путь.
# - Если в вашей задаче требуется найти «кратчайшее Х», попробуйте 
# смо­делировать свою задачу графом и воспользуйтесь поиском в ширину
# для ее решения.
# - В направленном графе есть стрелки, а отношения действуют в направле­нии 
# стрелки (Рама -> Адит означает «Рама должен Адиту» ).
# - В ненаправленных графах стрелок нет, а отношение идет в обе стороны
# (Росс <-> Рэйчел означает «Росс встречается с Рэйчел, а Рэйчел 
# встреча­ется с Россом».)
# - Очереди относятся к категории FIFO («первым вошел, первым вышел»).
# - Стек относится к категории LIFO («последним пришел, первым вышел»).
# - Людей следует проверять в порядке их добавления в список поиска, поэтому
# список поиска должен быть оформлен в виде очереди, 
# иначе найденный путь не будет кратчайшим.
# - Позаботьтесь о том, чтобы уже прове­ренный
# человек не проверялся заново,иначе может возникнуть бесконечный цикл .
#
#
#
#
from collections import deque                   # импорт очереди
graph = {}                                      # создаем граф   
graph ["you"] = [ "alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", "jonny"]
graph["anuj"] = []
graph["peggy"] = []
graph["thom"] = []
graph["jonny"] = []
def person_is_seller(name):                     # определяем функцию проверки
    return name[-1] == 'm'
def search(name):                               # определяем функцию поиска в ширину
    search_queue = deque()                      # создаем пустую очередь
    search_queue += graph[name]                 # добавляем в очередь соседей узла 
    searched = []                   # массив для отслеживания уже проверенных значений 
    while search_queue is not None:             # пока очередь не пуста            
        person = search_queue.popleft()     # из очереди извлекается первое значение
        if person not in searched:
            if person_is_seller(person):        # происходит нужная проверка
                print(person + ' is a mango seller!')
                return True
            else:                               # проверка не пройдена
                search_queue += graph[person]   # все соседи узла добавляются в очередь
                searched.append(person)         # значение добавляется в проверенные
    return False                            # в графе не нашлось искомого элемента
search("you")