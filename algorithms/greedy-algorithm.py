# - Жадные алгоритмы стремятся к локальной оптимизации в расчете на то,
# что в итоге будет достигнут глобальный оптимум.
# - У NР-полных задач не существует известных быстрых решений.
# - Если у вас имеется NР-полная задача, лучше всего воспользоваться при­
# ближенным алгоритмом.
# - Жадные алгоритмы легко реализуются и быстро выполняются, поэтому
# из них получаются хорошие приближенные алгоритмы.

# Задача о покрытии множества
# Вы открываете собственную авторскую програм­ve на радио и хотите,
#  чтобы вас слушали во всех50 штатах. Нужно решить, на каких радиостанциях­
# должна транслироваться ваша передача. Каждая станция стоит денег,
#  поэтому количество станций не­обходимо свести к минимуму.
#  Имеется список станций.
# Каждая станция покрывает определенный набор штатов, эти наборы пере­крываются.
# Проблема в том , что вычисление всех возможных подмножеств станций
# займет слишком много времени.

# На помощь приходят жадные алгоритмы! Вот как выглядит жадный алго­
# ритм, который выдает результат, достаточно близкий к оптимуму:
# 1. Выбрать станцию, покрывающую наибольшее количество штатов, еще
# не входящих в покрытие. Если станция будет покрывать некоторые
# штаты , уже входящие в покрытие, это нормально.
# 2. Повторять, пока остаются штаты, не входящие в покрытие.

from PIL import Image
myImage = Image.open('algorithms/greed-alg-ex.png');
#myImage.show()  # чтобы посмотреть условие, убери шарп в начале строки 
# В этом примере для простоты будет использоваться небольшое подмноже­ство
#  штатов и станций.
# Сначала составьте список штатов:

states_needed = set(["mt", "wa", "or", "id", "nv", "ut",'ca','az'])

# Также понадобится список станций, из которого будет выбираться покры­тие.
#  Я решил воспользоваться хешем:

stations = {}
stations["kone"] = set(["id", "nv", "ut"])  #станция kone вещает в штатах 
stations["ktwo"] = set(["wa", "id", "mt"])  #Айдахо (id), Невада (nv) и Юта (ut)
stations["kthree"] = set(["or", "nv", "ca"]) # и т.д.   
stations["kfour"] = set(["nv", "ut"])
stations["kfive"] = set(["ca", "az"])

# нам понадобится структура данных для хранения итогового на­бора станций:

final_stations = set()

# Теперь необходимо вычислить набор используемых станций .
# Вы перебираете все станции и выбираете ту, которая обслуживает больше
# всего штатов, невходящих в текущее покрытие. Будем называть ее best_station:

while states_needed:
    best_station = None
    states_covered = set()
# Множество states_covered содержит все штаты , обслуживаемые этой стан­цией,
# которые еще не входят в текущее покрытие. Цикл for перебирает все
# станции и находит среди них наилучшую.    
    for station, states in stations.items():
        covered = states_needed & states # <-- персечение множеств
# Множество covered содержит штаты, присутствующие как в states_needed,
# так и в states_for _station. Таким образом, covered-множество штатов, не
# входящих в покрытие, которые покрываются текущей станuией! Затем мы
# проверяем, покрывает ли эта станция больше штатов, чем текущая станция best_station:
        if len(covered) > len(states_covered):
# Если условие выполняется, то станция сохраняется в best_station .
#  Нако­нец, после завершения цикла best_station добавляется
#  в итоговый список станций:
            best_station = station
            states_covered = covered
# Также необходимо обновить содержимое states_needed. Те штаты , которые
# входят в зону покрытия станции, больше не нужны:
    states_needed -= states_covered
    final_stations.add(best_station)

print(final_stations)