# Хеши хорошо подходят для решения следующих задач:
# моделирование отношений между объектами
# устранение дубликатов
# кэширование/запоминание данных вместо выполнения работы на сер­вере
# Хэш таблицы - это словари.

voted = {}                      # создаем пустую хэш таблицу
def check_voter(name):
    if voted.get(name):         # проверяем если ли голосовавший в таблице
        print('Kick them out!')     
    else:
        voted[name] = True
        print('let the vote!')
check_voter('Tom')              # let the vote! голосовать можно, в списке нет
check_voter('Mike')             # let the vote! голосовать можно, в списке нет
check_voter('Mike')             # Kick them out! голосовать нельзя, есть в списке
print(voted)                    # {'Tom': True, 'Mike': True} актуальная таблица


# Коллизии - это, когда двум ключам назначается один элемент массива.
# Решение: если несколько ключей отображаются на один элемент, в этом элементе
# создается связанный список.
# - Выбор хеш-функции действительно важен. Хеш-функция, отображаю­щая
# все ключи на один элемент массива, никуда не годится. В идеале
# хеш-функция должна распределять ключи равномерно по всему хешу;
# - Если связанные списки становятся слишком длинными, работа с хеш-
# таблицей сильно замедляется. Но они не станут слишком длинными при
# использовании хорошей хеш-функции!
# - Хеш-таблица создается объединением хеш-функции с массивом.
# - Коллизии нежелательны. Хеш -функция должна свести количество кол­лизий к минимуму.
# - Хеш-таблицы обеспечивают очень быстрое выполнение поиска, вставки
# и удаления.
# - Хеш-таблицы хорошо подходят для моделирования отношений между
# объектами.
# - Как только коэффициент заполнения превышает 0,7, пора изменять­
# размер хеш-таблицы .
# - Хеш-таблицы используются для кэширования данных (например, на
# веб-серверах ).
# - Хеш-таблицы хорошо подходят для обнаружения дубликатов.
